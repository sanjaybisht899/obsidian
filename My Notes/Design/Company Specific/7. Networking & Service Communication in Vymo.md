
---
### **1. How do you handle inter-service communication failures?**

Vymo follows **resilient microservices architecture** with:

âœ… **Retry & Circuit Breaker Mechanisms:**

- **Resilience4j / Hystrix** â†’ Auto-retries failed requests with exponential backoff.
- **Circuit Breakers** â†’ If a service is down, it temporarily stops sending requests to avoid cascading failures.

âœ… **Timeout & Fallback Strategies:**

- **Timeouts** set for external calls to avoid indefinite waiting.
- **Fallback Mechanisms** â†’ If a service fails, a cached or default response is served.

âœ… **Bulkhead Pattern:**

- Limits resource usage per service to prevent a single failure from affecting the entire system.

âœ… **Dead Letter Queues (DLQ) for Asynchronous Calls:**

- Failed messages are stored in a queue for later processing.

---

### **2. What messaging queues or event-driven mechanisms do you use?**

ðŸ”¹ **Apache Kafka** â†’ Main event bus for async communication between microservices.  
ðŸ”¹ **RabbitMQ** â†’ Used for lightweight messaging where persistence isnâ€™t required.  
ðŸ”¹ **WebSockets / Server-Sent Events (SSE)** â†’ For real-time notifications and updates.  
ðŸ”¹ **gRPC for High-Performance RPC Calls** â†’ Between critical low-latency services.  
ðŸ”¹ **Amazon SQS (for AWS services)** â†’ For decoupled processing of tasks.

---

### **3. How do you optimize API latency?**

âš¡ **API Gateway Optimization (Kong / AWS API Gateway):**

- Implements **request aggregation** to reduce round trips.
- Uses **gzip compression** for reduced payload size.
- **GraphQL for selective data fetching** instead of multiple REST calls.

âš¡ **CDN (Cloudflare / AWS CloudFront):**

- Caches static content at the edge to reduce latency for global users.

âš¡ **Database Query Optimization:**

- **Read replicas & caching (Redis, Memcached).**
- **Indexing & partitioning** to speed up queries.

âš¡ **Connection Pooling (HikariCP for Java apps):**

- Reduces overhead for frequent DB connections.

---

### **4. How do you handle rate limiting and API throttling?**

ðŸ”¹ **Rate Limiting at API Gateway (Kong / AWS WAF)**

- Limits requests per IP to prevent abuse (e.g., **100 requests/min per user**).

ðŸ”¹ **Token Bucket Algorithm** for fair request distribution.

ðŸ”¹ **Quota-based API Access** for different customer tiers.

ðŸ”¹ **Dynamic Scaling with Kubernetes HPA**

- Automatically increases instances when request rates spike.

ðŸ”¹ **Monitoring & Alerting (Prometheus + Grafana)**

- Detects high API traffic & auto-scales services.

---
