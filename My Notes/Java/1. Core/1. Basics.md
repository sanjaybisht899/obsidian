
---

### 1. **What is Java?**

Java is a popular programming language known for being:

- **Object-Oriented**: Focused on creating reusable objects in code.
- **Platform-Independent**: Java code runs on any machine with a Java Virtual Machine (JVM).
- **Secure**: Provides built-in security features to protect against threats.
- **Robust**: Handles errors effectively using exceptions.
- **Multithreaded**: Supports running multiple tasks simultaneously.

#### Key Features:

- **Simple**: Easy to learn with clear syntax.
- **Portable**: Code can move across platforms without needing changes.
- **High Performance**: JIT compiler optimizes the performance.

---

### 2. **JDK, JRE, and JVM**

Java operates using three main components:
#### **Java Development Kit (JDK)**

- A **developer's toolkit** that includes tools like a compiler, debugger, and libraries to write and compile Java programs.
- Contains **JRE + Development Tools**.

#### **Java Runtime Environment (JRE)**

- Provides the environment needed to run Java programs.
- Includes **JVM + Libraries** to execute the bytecode.

#### **Java Virtual Machine (JVM)**

- A virtual engine that converts Java **bytecode** into machine code specific to the underlying operating system.
- Manages memory and execution.

---

### 3. **How Java is Platform-Independent**

Java achieves platform independence using the **Java Virtual Machine (JVM)** and the **Java Runtime Environment (JRE)**:

1. Developers write Java code and compile it into **bytecode** using the `javac` compiler.
2. This **bytecode** is universal and can run on any machine with a compatible **JRE** 
3. The **JVM** translates bytecode into machine-specific instructions for execution.

This is why Java is known as **"Write Once, Run Anywhere" (WORA)**.

---

### 4. **How JVM Works**

1. **Write & Compile**:
    - You write Java code (`.java` file).
    - `javac` compiler converts it into **bytecode** (`.class` file).
2. **Class Loader**:
    - Loads the bytecode into the JVM.
    - Ensures the code is safe and valid.
3. **Execution Engine**:
    - **Interpreter**: Converts bytecode to machine instructions line by line.
    - **JIT Compiler**: Speeds up execution by converting frequently used bytecode into native machine code.
4. **Garbage Collection**:    
    - JVM automatically removes unused objects from memory.


---

### 5. **JIT Compiler**

The **JIT (Just-In-Time) Compiler** is a part of the **JVM Execution Engine** that improves the performance of Java applications by converting frequently used bytecode into **native machine code** during runtime.

---

1. **Starts with the Interpreter**:
    
    - Initially, the JVM interprets bytecode line by line.
2. **Identifies "Hot Code"**:
    
    - The JIT compiler identifies code that is executed repeatedly (called "hotspots").
3. **Compiles to Native Code**:
    
    - Converts this "hot code" into optimized machine code (specific to the system's architecture).
4. **Speeds Up Execution**:
    
    - The native code runs faster because it skips interpretation for those parts.

---

### 7. **Java's `main` Method**

- The entry point of any Java program:
    
    ```java
    public static void main(String[] args) {
        // Code goes here
    }
    ```
    

#### Why is `main` defined this way?

- **`public`**: Accessible from anywhere.
- **`static`**: Doesn't need an object to be invoked.
- **`void`**: Doesn't return any value.
- **`String[] args`**: Used to accept command-line arguments.

---

### 8. **Important Notes about the `main` Method**

- **`main` is not a keyword**: It's just the name of the method.
- You **cannot write `public void static`**: The order of modifiers matters; it must be `public static void`.
- If you run the program **without arguments**, the `args` array will be empty but not null.

---

### 9. **Local Variables in Java**

- Local variables are declared inside methods or blocks.
- **No default value** is assigned to local variables. You must initialize them before use. For example:
    
    ```java
    int x; // Error: x is not initialized
    ```
    

---

### 10. **Default Values for Class Variables**

Unlike local variables, class variables (instance or static) get default values:

- Numeric types: `0` or `0.0`
- `char`: `'\u0000'` (null character)
- `boolean`: `false`
- Object references: `null`

---

# Questions

* How is java secure?
	- **Bytecode Verification** ‚Üí Ensures safe execution of Java code.
	- **Automatic Memory Management** ‚Üí Prevents memory leaks and buffer overflows.
	- **Sandboxing** ‚Üí Restricts untrusted code from accessing system resources.
	- **Security Manager & Access Control** ‚Üí Defines permissions for Java applications.
	- **ClassLoader Mechanism** ‚Üí Prevents unauthorized class loading.
	- **Cryptography & Secure Communication** ‚Üí Provides encryption and secure connections.
	- **Protection Against Common Attacks** ‚Üí Prevents buffer overflow, integer overflow, and unauthorized memory access.
	- **Regular Updates Required** ‚Üí Security improves with Java updates.
	- **Developer Responsibility** ‚Üí Secure coding practices are essential.

---
### Default Value of variables

### **Default Values in Java**

#### **1. Primitive Data Types Default Values:**

|Data Type|Default Value|
|---|---|
|byte|0|
|short|0|
|int|0|
|long|0L|
|float|0.0f|
|double|0.0d|
|char|'\u0000' (null character)|
|boolean|false|

#### **2. Object Variables (Reference Types):**

- **Default Value:** `null`

üîπ **Note:** Local variables **do not have default values** and must be initialized before use.
Only class variables have default type.

---
```java
class Main {
    static int i;
    int k;

    public static void main(String[] args) {
        int j;
        static int l; // ‚ùå Error: Cannot declare static variable inside a method
        System.out.println(i); // ‚úÖ Prints: 0
        System.out.println(j); // ‚ùå Error: Local variable j might not have been initialized
        System.out.println(k); // ‚ùå Error: Non-static variable k cannot be accessed from a static method
        System.out.println(l); // ‚ùå Error: l is not declared properly
    }
}
```
**‚úÖ Corrected Code**
```java
class Main {
    static int i;  // ‚úÖ Static variable (default value: 0)
    static int l;  // ‚úÖ Static variable (default value: 0)
    int k;         // ‚úÖ Instance variable (default value: 0)

    public static void main(String[] args) {
        int j = 10; // ‚úÖ Local variable must be initialized

        System.out.println(i); // ‚úÖ Prints: 0
        System.out.println(j); // ‚úÖ Prints: 10

        Main obj = new Main(); // ‚úÖ Create an instance to access k
        System.out.println(obj.k); // ‚úÖ Prints: 0

        System.out.println(l); // ‚úÖ Prints: 0
    }
}
```

### **üîç Explanation of Errors & Fixes**

|**Error**|**Issue**|**Fix**|
|---|---|---|
|`static int l;` inside `main()`|**Static variables cannot be declared inside methods.**|Moved `static int l;` to the class level.|
|`System.out.println(j);`|**Local variables do not get default values.**|Initialized `j = 10;` before using it.|
|`System.out.println(k);`|**Instance variables need an object to be accessed inside static methods.**|Created an object: `Main obj = new Main();`|

---

### **üìå Final Output**

```
0
10
0
0
```

---
# Classloader

### **Role of Class Loader in Java**

The **Class Loader** in Java is responsible for **loading classes into memory** when a Java program runs. It ensures that Java classes are **dynamically loaded** when required.

---

## **1Ô∏è‚É£ What is a Class Loader?**

- The Class Loader **loads compiled `.class` files** into the JVM.
- It **converts bytecode** into a format that the JVM can understand.
- It follows the **parent delegation model** to load classes efficiently and prevent conflicts.

---

## **2Ô∏è‚É£ Types of Class Loaders in Java**

Java provides **three main types** of class loaders:

### **1. Bootstrap Class Loader (Primordial Loader)**

- **Loads Java‚Äôs core classes** (e.g., `java.lang.String`, `java.util.List`).
- Loads classes from the **JDK‚Äôs `rt.jar` or `lib` directory**.
- It **does not have a parent** because it is part of the JVM itself.

### **2. Extension Class Loader**

- Loads classes from the **`lib/ext` directory** or the location specified in `java.ext.dirs`.
- Loads Java's **standard extension libraries**.

### **3. Application (System) Class Loader**

- Loads **classes from the classpath (`CLASSPATH` environment variable)**.
- Loads classes in **`bin/` or JAR files in `lib/`**.

---

## **3Ô∏è‚É£ How Class Loading Works?**

### **Class Loading Steps:**

1. **Loading** ‚Üí Reads bytecode (`.class` file) and loads it into JVM memory.
2. **Linking** ‚Üí Verifies bytecode, allocates memory for static variables.
3. **Initialization** ‚Üí Initializes static variables and runs static blocks.

### **Example:**

```java
public class Demo {
    static {
        System.out.println("Class Loaded!");
    }
    
    public static void main(String[] args) throws ClassNotFoundException {
        // Explicitly loading class
        Class.forName("Demo");
    }
}
```

**Output:**

```
Class Loaded!
```

---

## **4Ô∏è‚É£ Parent Delegation Model (How Class Loaders Work Together?)**

- **A child class loader first asks its parent to load a class.**
- If the parent **fails**, then the child loads it.
- Prevents **class conflicts** and maintains **security**.

### **Example of Delegation:**

4. `Application ClassLoader` ‚Üí Asks `Extension ClassLoader`
5. `Extension ClassLoader` ‚Üí Asks `Bootstrap ClassLoader`
6. If `Bootstrap ClassLoader` **cannot find** the class, then the lower class loader loads it.

---

## **5Ô∏è‚É£ Custom Class Loader (When to Use?)**

- When you need to **load encrypted classes**.
- When implementing **hot-reloading in applications**.

### **Example: Custom Class Loader**

```java
import java.io.*;

public class CustomClassLoader extends ClassLoader {
    @Override
    public Class<?> findClass(String name) throws ClassNotFoundException {
        byte[] bytecode = loadClassData(name);
        return defineClass(name, bytecode, 0, bytecode.length);
    }

    private byte[] loadClassData(String name) {
        // Load class file into byte array (For simplicity, returning an empty array)
        return new byte[0];
    }
    
    public static void main(String[] args) throws Exception {
        CustomClassLoader loader = new CustomClassLoader();
        Class<?> clazz = loader.loadClass("MyClass");
        System.out.println("Class Loaded: " + clazz.getName());
    }
}
```

---

## **6Ô∏è‚É£ Summary (Why is Class Loader Important?)**

|Feature|Purpose|
|---|---|
|**Dynamically loads classes**|Loads only when needed, saving memory.|
|**Follows delegation model**|Prevents duplicate class loading.|
|**Allows custom class loaders**|Used in frameworks like Spring & Hibernate.|

---
