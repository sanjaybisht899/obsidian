

# Question

---
## Comparable vs Comparator
#### 1. **Comparable**:

- **Definition**: `Comparable` is used to define the **natural ordering** of objects in a class.
- **Package**: Found in `java.lang`.
- **Method**: Contains the method `compareTo(Object o)`.
- **Implementation**: A class must implement the `Comparable` interface and override the `compareTo` method to define its natural order.

#### **Usage**:

- It’s suitable when you want a **default sorting order** for objects of a class.
- Only one sorting logic can be defined in a class (natural ordering).

#### **Code Example**:

```java
import java.util.*;

class Student implements Comparable<Student> {
    int rollNo;
    String name;

    Student(int rollNo, String name) {
        this.rollNo = rollNo;
        this.name = name;
    }

    @Override
    public int compareTo(Student other) {
        return this.rollNo - other.rollNo; // Sorting by roll number (ascending)
    }
}

public class Main {
    public static void main(String[] args) {
        List<Student> students = Arrays.asList(
                new Student(3, "John"),
                new Student(1, "Alice"),
                new Student(2, "Bob")
        );

        Collections.sort(students); // Sort using Comparable
        students.forEach(s -> System.out.println(s.rollNo + " " + s.name));
    }
}
```

**Output**:

```
1 Alice
2 Bob
3 John
```

---

### **2. Comparator**:

- **Definition**: `Comparator` is used to define **custom sorting orders**.
- **Package**: Found in `java.util`.
- **Method**: Contains the method `compare(Object o1, Object o2)`.
- **Implementation**: Comparators are implemented as separate classes or as lambda expressions to provide multiple sorting logics.

#### **Usage**:

- Use `Comparator` when:
    - You need **multiple sorting criteria**.
    - The natural order defined by `Comparable` is not sufficient.

#### **Code Example**:

```java
import java.util.*;

class Student {
    int rollNo;
    String name;

    Student(int rollNo, String name) {
        this.rollNo = rollNo;
        this.name = name;
    }
}

public class Main {
    public static void main(String[] args) {
        List<Student> students = Arrays.asList(
                new Student(3, "John"),
                new Student(1, "Alice"),
                new Student(2, "Bob")
        );

        // Sort by name
        students.sort(Comparator.comparing(s -> s.name));
        System.out.println("Sorted by Name:");
        students.forEach(s -> System.out.println(s.rollNo + " " + s.name));

        // Sort by roll number (descending)
        students.sort((s1, s2) -> s2.rollNo - s1.rollNo);
        System.out.println("\nSorted by Roll Number (Descending):");
        students.forEach(s -> System.out.println(s.rollNo + " " + s.name));
    }
}
```

**Output**:

```
Sorted by Name:
1 Alice
2 Bob
3 John

Sorted by Roll Number (Descending):
3 John
2 Bob
1 Alice
```

---

### **Key Differences**

|**Aspect**|**Comparable**|**Comparator**|
|---|---|---|
|**Package**|`java.lang`|`java.util`|
|**Method**|`compareTo(Object o)`|`compare(Object o1, Object o2)`|
|**Purpose**|Defines the natural sorting order of a class.|Defines custom sorting logic.|
|**Implementation**|Implemented by the class to be sorted.|Implemented in a separate class or lambda.|
|**Flexibility**|Limited to one sorting logic.|Allows multiple sorting logics.|
|**Sorting Logic**|Added inside the class.|Defined externally or on demand.|

---

### When to Use?

- Use **`Comparable`** when:
    - A single, natural sorting order suffices.
    - Sorting is intrinsic to the object (e.g., sorting by `rollNo` for students).
- Use **`Comparator`** when:
    - Multiple sorting orders are needed (e.g., sort by `name`, `rollNo`, etc.).
    - Sorting logic is external to the object’s definition.
