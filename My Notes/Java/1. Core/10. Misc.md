

# Question

---
## Comparable vs Comparator
#### 1. **Comparable**:

- **Definition**: `Comparable` is used to define the **natural ordering** of objects in a class.
- **Package**: Found in `java.lang`.
- **Method**: Contains the method `compareTo(Object o)`.
- **Implementation**: A class must implement the `Comparable` interface and override the `compareTo` method to define its natural order.

#### **Usage**:

- It’s suitable when you want a **default sorting order** for objects of a class.
- Only one sorting logic can be defined in a class (natural ordering).

#### **Code Example**:

```java
import java.util.*;

class Student implements Comparable<Student> {
    int rollNo;
    String name;

    Student(int rollNo, String name) {
        this.rollNo = rollNo;
        this.name = name;
    }

    @Override
    public int compareTo(Student other) {
        return this.rollNo - other.rollNo; // Sorting by roll number (ascending)
    }
}

public class Main {
    public static void main(String[] args) {
        List<Student> students = Arrays.asList(
                new Student(3, "John"),
                new Student(1, "Alice"),
                new Student(2, "Bob")
        );

        Collections.sort(students); // Sort using Comparable
        students.forEach(s -> System.out.println(s.rollNo + " " + s.name));
    }
}
```

**Output**:

```
1 Alice
2 Bob
3 John
```

---

### **2. Comparator**:

- **Definition**: `Comparator` is used to define **custom sorting orders**.
- **Package**: Found in `java.util`.
- **Method**: Contains the method `compare(Object o1, Object o2)`.
- **Implementation**: Comparators are implemented as separate classes or as lambda expressions to provide multiple sorting logics.

#### **Usage**:

- Use `Comparator` when:
    - You need **multiple sorting criteria**.
    - The natural order defined by `Comparable` is not sufficient.

#### **Code Example**:

```java
import java.util.*;

class Student {
    int rollNo;
    String name;

    Student(int rollNo, String name) {
        this.rollNo = rollNo;
        this.name = name;
    }
}

public class Main {
    public static void main(String[] args) {
        List<Student> students = Arrays.asList(
                new Student(3, "John"),
                new Student(1, "Alice"),
                new Student(2, "Bob")
        );

        // Sort by name
        students.sort(Comparator.comparing(s -> s.name));
        System.out.println("Sorted by Name:");
        students.forEach(s -> System.out.println(s.rollNo + " " + s.name));

        // Sort by roll number (descending)
        students.sort((s1, s2) -> s2.rollNo - s1.rollNo);
        System.out.println("\nSorted by Roll Number (Descending):");
        students.forEach(s -> System.out.println(s.rollNo + " " + s.name));
    }
}
```

**Output**:

```
Sorted by Name:
1 Alice
2 Bob
3 John

Sorted by Roll Number (Descending):
3 John
2 Bob
1 Alice
```

---

### **Key Differences**

|**Aspect**|**Comparable**|**Comparator**|
|---|---|---|
|**Package**|`java.lang`|`java.util`|
|**Method**|`compareTo(Object o)`|`compare(Object o1, Object o2)`|
|**Purpose**|Defines the natural sorting order of a class.|Defines custom sorting logic.|
|**Implementation**|Implemented by the class to be sorted.|Implemented in a separate class or lambda.|
|**Flexibility**|Limited to one sorting logic.|Allows multiple sorting logics.|
|**Sorting Logic**|Added inside the class.|Defined externally or on demand.|

---

### When to Use?

- Use **`Comparable`** when:
    - A single, natural sorting order suffices.
    - Sorting is intrinsic to the object (e.g., sorting by `rollNo` for students).
- Use **`Comparator`** when:
    - Multiple sorting orders are needed (e.g., sort by `name`, `rollNo`, etc.).
    - Sorting logic is external to the object’s definition.

---
Spread operator in javascript so what is there in java for the exact same thing

### **1. Variable Arguments (`varargs`) – Equivalent to Spread in Function Calls**

In JavaScript:

```javascript
function sum(...numbers) {
    return numbers.reduce((acc, num) => acc + num, 0);
}
console.log(sum(1, 2, 3, 4)); // Output: 10
```

In Java:

```java
public class Main {
    public static int sum(int... numbers) { // varargs
        int total = 0;
        for (int num : numbers) {
            total += num;
        }
        return total;
    }

    public static void main(String[] args) {
        System.out.println(sum(1, 2, 3, 4)); // Output: 10
    }
}
```

### **2. `Arrays.copyOf()` – Equivalent to Spreading Arrays**

In JavaScript:

```javascript
let arr1 = [1, 2, 3];
let arr2 = [...arr1, 4, 5]; // Spread operator
console.log(arr2); // [1, 2, 3, 4, 5]
```

In Java:

```java
import java.util.Arrays;

public class Main {
    public static void main(String[] args) {
        int[] arr1 = {1, 2, 3};
        int[] arr2 = Arrays.copyOf(arr1, arr1.length + 2);
        arr2[3] = 4;
        arr2[4] = 5;
        System.out.println(Arrays.toString(arr2)); // Output: [1, 2, 3, 4, 5]
    }
}
```

### **3. `Collections.addAll()` – Equivalent to Spreading Collections**

In JavaScript:

```javascript
let set1 = new Set([1, 2, 3]);
let set2 = new Set([...set1, 4, 5]); // Spread operator with Set
console.log(set2); // Set {1, 2, 3, 4, 5}
```

In Java:

```java
import java.util.*;

public class Main {
    public static void main(String[] args) {
        Set<Integer> set1 = new HashSet<>(Arrays.asList(1, 2, 3));
        Set<Integer> set2 = new HashSet<>(set1);
        set2.addAll(Arrays.asList(4, 5));
        System.out.println(set2); // Output: [1, 2, 3, 4, 5]
    }
}
```

### **4. `Stream.concat()` – Equivalent to Spreading Multiple Arrays**

In JavaScript:

```javascript
let arr1 = [1, 2, 3];
let arr2 = [4, 5];
let arr3 = [...arr1, ...arr2]; // Spread operator
console.log(arr3); // [1, 2, 3, 4, 5]
```

In Java:

```java
import java.util.*;
import java.util.stream.*;

public class Main {
    public static void main(String[] args) {
        List<Integer> list1 = Arrays.asList(1, 2, 3);
        List<Integer> list2 = Arrays.asList(4, 5);
        List<Integer> merged = Stream.concat(list1.stream(), list2.stream()).collect(Collectors.toList());
        System.out.println(merged); // Output: [1, 2, 3, 4, 5]
    }
}
```

---
