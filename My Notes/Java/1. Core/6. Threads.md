
---

#### **What is a Thread in Java?**

A **Thread** in Java is a lightweight process that allows concurrent execution of tasks. It runs within the context of a process and shares the process's resources.

There are **two common ways** to create a thread in Java:

1. **By Extending the `Thread` class**.
2. **By Implementing the `Runnable` interface**.
---
### **1. Extending the `Thread` Class**

- Subclass the `Thread` class and override its `run()` method.
- Start the thread using the `start()` method.

**Example**:

```java
class MyThread extends Thread {
    @Override
    public void run() {
        System.out.println("Thread running by extending Thread class.");
    }
}

public class Test {
    public static void main(String[] args) {
        MyThread t = new MyThread();
        t.start(); // Starts a new thread
    }
}
```

---

### **2. Implementing the `Runnable` Interface**

- Implement the `Runnable` interface and define the `run()` method.
- Pass the `Runnable` object to a `Thread` instance and call `start()`.

**Example**:

```java
class MyRunnable implements Runnable {
    @Override
    public void run() {
        System.out.println("Thread running by implementing Runnable.");
    }
}

public class Test {
    public static void main(String[] args) {
        Thread t = new Thread(new MyRunnable());
        t.start(); // Starts a new thread
    }
}
```
### **Difference Between `Thread` vs. `Runnable`**

|**Aspect**|**Extending `Thread`**|**Implementing `Runnable`**|
|---|---|---|
|**Inheritance**|Requires subclassing the `Thread` class, so you cannot extend other classes.|Allows extending other classes, promoting better design.|
|**Reusability**|Thread class logic is tightly coupled to the thread.|Runnable provides better separation of thread logic.|
|**Object Sharing**|Not ideal for sharing a threadâ€™s logic across objects.|Multiple threads can share the same `Runnable` object.|
|**Code Design**|Less flexible; tightly binds thread behavior to the class.|Promotes cleaner and modular code.|

### **Recommendation**

Prefer **`Runnable`** for better design, flexibility, and reusability.

---

#### **What is the Priority of a Thread and How is it Used in Scheduling?**

Thread priority determines the order in which threads are scheduled for execution by the JVM. Higher priority threads are given preference, but thread scheduling ultimately depends on the underlying OS.

- Priorities range from **1 (MIN_PRIORITY)** to **10 (MAX_PRIORITY)**.

---

#### **What is the Default Priority of a Thread in Java?**

The default priority of a thread is **5 (NORM_PRIORITY)**.

```java
public class ThreadPriorityExample {
    public static void main(String[] args) {
        Thread thread = new Thread(() -> System.out.println("Thread running"));
        System.out.println("Default Priority: " + thread.getPriority());
    }
}
```

---

#### **Three Different Priorities for Threads in Java**

1. **MIN_PRIORITY**: Value is 1.
2. **NORM_PRIORITY**: Value is 5 (default).
3. **MAX_PRIORITY**: Value is 10.

---

#### **What is the Purpose of the `join()` Method in the Thread Class?**

The `join()` method allows one thread to wait for the completion of another. For example, a thread can pause its execution until another thread finishes.

```java
class MyThread extends Thread {
    @Override
    public void run() {
        System.out.println("Child thread is running...");
    }
}

public class Main {
    public static void main(String[] args) throws InterruptedException {
        MyThread thread = new MyThread();
        thread.start();
        thread.join(); // Main thread waits for MyThread to finish
        System.out.println("Main thread resumes after child thread");
    }
}
```

---

#### **Difference Between `wait()` and `sleep()`**

- **`wait()`**: Releases the lock and pauses the thread until another thread notifies it.
- **`sleep()`**: Puts the thread to sleep for a specified duration but does not release the lock.

```java
class WaitAndSleepExample {
    public static void main(String[] args) throws InterruptedException {
        Object lock = new Object();
        synchronized (lock) {
            lock.wait(); // Waits for a notification
        }
        
        Thread.sleep(1000); // Sleeps for 1 second
    }
}
```

---

#### **Is it Possible to Call `run()` Instead of `start()` on a Thread?**

Yes, but calling `run()` directly does not start a new thread. It simply executes the code in the current thread.

|**Aspect**|**`start()`**|**`run()`**|
|---|---|---|
|**Purpose**|Starts a new thread and executes `run()` in it.|Executes `run()` in the current thread.|
|**Creates a New Thread**|Yes|No|
|**Concurrency**|Code in `run()` runs concurrently with the main thread.|Code in `run()` runs sequentially in the main thread.|
|**System Resources**|Allocates system resources for a new thread.|No additional resources allocated.|

---

#### **What is a Daemon Thread in Java?**

A daemon thread runs in the background to perform tasks like garbage collection. It terminates automatically when all non-daemon threads finish execution.

---

#### **How to Make a Regular Thread a Daemon Thread?**

Use the `setDaemon(true)` method before starting the thread.

```java
public class DaemonExample {
    public static void main(String[] args) {
        Thread daemonThread = new Thread(() -> System.out.println("Daemon thread running"));
        daemonThread.setDaemon(true);
        daemonThread.start();
    }
}
```

---

#### **What is Concurrency and How to Achieve It?**

Concurrency refers to the ability to execute multiple tasks simultaneously. It can be achieved using:

- **Threads**
- **Executor Framework**
- **Fork/Join Framework**
- **CompletableFuture**

---

### **Key Multithreading Concepts**

#### **Executors (Thread Pooling)**

The **Executor framework** provides a way to manage and reuse threads.

```java
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

public class ExecutorExample {
    public static void main(String[] args) {
        ExecutorService executor = Executors.newFixedThreadPool(2);

        executor.submit(() -> System.out.println("Task 1"));
        executor.submit(() -> System.out.println("Task 2"));
        
        executor.shutdown();
    }
}
```

---

#### **Synchronization**

Ensures that only one thread accesses a critical section at a time.

```java
class Counter {
    private int count = 0;

    public synchronized void increment() {
        count++;
    }

    public int getCount() {
        return count;
    }
}
```

---

#### **Locks and Conditions**

Java provides the `Lock` interface and `Condition` for advanced thread synchronization.

```java
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

public class LockExample {
    private final Lock lock = new ReentrantLock();

    public void criticalSection() {
        lock.lock();
        try {
            System.out.println("Critical section");
        } finally {
            lock.unlock();
        }
    }
}
```

---

#### **Concurrent Collections**

Thread-safe collection classes like `ConcurrentHashMap` and `CopyOnWriteArrayList`.

---

#### **Atomic Variables**

Used for atomic operations on single variables.

```java
import java.util.concurrent.atomic.AtomicInteger;

public class AtomicExample {
    private final AtomicInteger count = new AtomicInteger();

    public void increment() {
        count.incrementAndGet();
    }

    public int getCount() {
        return count.get();
    }
}
```

---

#### **Fork/Join Framework**

Used for parallel processing by breaking tasks into subtasks.

---

#### **CompletableFuture**

Used for asynchronous programming in Java.

---

### **Benefits of Multithreading**

1. Improved performance and responsiveness.
2. Efficient use of system resources.
3. Parallelism for computational tasks.

---

### **Best Practices**

- Use thread pools instead of creating new threads.
- Minimize synchronization to avoid contention.
- Use concurrent collections for thread safety.

---

#### **Thread Pools in Java**

Thread pools manage a group of reusable threads to execute tasks efficiently.

```java
ExecutorService executor = Executors.newFixedThreadPool(4);
executor.submit(() -> System.out.println("Task running"));
executor.shutdown();
```

#### **Why Use Thread Pools?**

- Better resource management.
- Improved performance by reusing threads.
- Avoids the overhead of thread creation and destruction.

# Question

1. What is volatile keyword?
	- The `volatile` keyword is used to indicate that a variable's value will be modified by multiple threads.
	- It ensures that changes made to the variable in one thread are immediately visible to other threads.
	- #### **Characteristics**:
		1. **Prevents Caching**:
		    - A `volatile` variable is not cached locally by threads.
		    - Every read and write operation happens directly in the main memory.
		2. **Visibility Guarantee**:
		    - When a thread updates a `volatile` variable, all other threads see the updated value.
		3. **Does Not Ensure Atomicity**:
		    - Operations on a `volatile` variable are not atomic (e.g., `counter++` is not thread-safe).
		4. **Applicable Only to Variables**:
		    - Cannot be used with methods, classes, or blocks.
- 2. What is transient keyword?
	-  The `transient` keyword is used to indicate that a variable should not be serialized.
	- During serialization, transient variables are **not included** in the serialized state of an object.
	- #### **Characteristics**:
		1. **Serialization**:
		    
		    - Used with `Serializable` objects.
		    - When an object is serialized, transient variables are skipped.
		2. **Default Value After Deserialization**:
		    
		    - Transient variables are initialized to their default values (`null` for objects, `0` for integers, `false` for booleans, etc.).
		3. **Applicable Only to Instance Variables**:
		    
		    - Cannot be applied to methods, classes, or static variables.