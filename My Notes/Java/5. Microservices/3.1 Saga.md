
---

In a **monolithic application**, transactions are managed by a single database using **ACID (Atomicity, Consistency, Isolation, Durability)** properties. However, in a **microservices architecture**, each service has its own database, making **distributed transactions** challenging. The **Saga pattern** ensures data consistency **without using a distributed transaction manager**.

---

## **ğŸ›  How Saga Works?**

A **business transaction** is split into a series of **local transactions**, where each service **executes a step** and publishes an event for the next service. If a step **fails**, a **compensating transaction** is triggered to undo the previous steps.

---

## **ğŸ“ When to Use the Saga Pattern?**

âœ… When a **single business operation spans multiple microservices**.  
âœ… When **eventual consistency** is acceptable.  
âœ… When a **global transaction lock is not feasible** (e.g., NoSQL, sharded databases).

---

## **ğŸ“Œ Example: E-commerce Order Processing (Saga Flow)**

### **Happy Path (Success)**

1ï¸âƒ£ **Order Service** creates an order â†’ **Event: `OrderCreated`**  
2ï¸âƒ£ **Payment Service** processes the payment â†’ **Event: `PaymentSuccess`**  
3ï¸âƒ£ **Inventory Service** updates stock â†’ **Event: `StockUpdated`**  
4ï¸âƒ£ **Order Service** marks order as **confirmed**

### **Failure Scenario**

If **payment fails**, a **compensating action** is triggered:  
âŒ **Payment Service fails** â†’ **Event: `PaymentFailed`**  
ğŸ”„ **Order Service** cancels the order â†’ **Event: `OrderCancelled`**

This rollback ensures that the system remains **consistent**.

---

## **ğŸ”„ Types of Saga Patterns**

There are **two main approaches** for implementing the Saga pattern:

| Saga Type                       | Description                                                                             | When to Use?                                                                |
| ------------------------------- | --------------------------------------------------------------------------------------- | --------------------------------------------------------------------------- |
| **1. Choreography-based Saga**  | Services communicate **directly** via **events**. No central controller.                | **Best for fewer microservices** with **simple workflows**.                 |
| **2. Orchestration-based Saga** | A **Saga Coordinator (Orchestrator)** manages the entire workflow by invoking services. | **Best for complex workflows** where services need **centralized control**. |

---

## **1ï¸âƒ£ Choreography-based Saga (Event-Driven)**

Each service **listens for events** and **reacts accordingly** without a central controller.

### **âœ” Advantages**

- **Loosely coupled** (each service acts independently).
- **Better scalability** (no single bottleneck).

### **âŒ Challenges**

- Hard to track & debug event flows.
- **Compensating actions must be carefully handled**.

### **ğŸ“Œ Example (Order Processing - Event Flow)**

- `OrderCreated` â†’ Payment Service listens â†’ `PaymentSuccess` â†’ Inventory Service listens â†’ `StockUpdated`
- If `PaymentFailed` â†’ Order Service **listens** and **cancels order**.

---

## **2ï¸âƒ£ Orchestration-based Saga (Centralized)**

A **Saga Orchestrator** manages the workflow by invoking services **explicitly**.

### **âœ” Advantages**

- **Centralized error handling** and **compensating actions**.
- **Easier to debug and manage** complex workflows.

### **âŒ Challenges**

- **Tightly coupled** (all services depend on the orchestrator).
- Single point of failure if orchestrator crashes.

### **ğŸ“Œ Example (Order Processing - Orchestrated Flow)**

1. **Order Service** calls **Orchestrator** to create an order.
2. **Orchestrator** calls **Payment Service** â†’ Payment succeeds.
3. **Orchestrator** calls **Inventory Service** â†’ Stock updated.
4. **Orchestrator** confirms the order.

If payment fails, the **Orchestrator** initiates a rollback (e.g., cancel order).

---

## **ğŸ’¡ Key Takeaways**

- **Choreography** â†’ **Event-driven**, best for **simple workflows**.
- **Orchestration** â†’ **Centralized**, best for **complex workflows**.
- **Saga ensures eventual consistency** in distributed transactions.
